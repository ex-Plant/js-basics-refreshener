<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
        content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'>
  <meta http-equiv='X-UA-Compatible'
        content='ie=edge'>
  <title>ARRAYS POP</title>
</head>
<body>
<script>

  const MAP = `

In JavaScript, both Maps and normal objects (i.e., plain JavaScript objects) can be used to store key-value pairs. However, there are several differences and advantages to using Maps over normal objects:

Key Types:
Objects: Keys are typically strings or symbols. Non-string keys are coerced to strings.
Maps: Keys can be of any type, including objects, functions, and primitives.
Order of Keys:
Objects: Do not guarantee the order of keys, although modern JavaScript engines do tend to maintain the order in which numeric keys are inserted.
Maps: Maintain the order of insertion of keys.
Performance:
Objects: May have better performance for simple key-value lookups if keys are strings.
Maps: Generally perform better for frequent additions and deletions of key-value pairs.
Size Property:
Objects: Do not have a built-in size property. You have to manually keep track of the size or use Object.keys(obj).length.
Maps: Have a size property that provides the number of key-value pairs directly.
Iteration:
Objects: To iterate over keys, you typically use for...in or Object.keys, Object.values, and Object.entries.
Maps: Provide a more straightforward and flexible iteration with methods like map.keys(), map.values(), and map.entries().
Prototypal Inheritance:
Objects: Inherit properties and methods from Object.prototype, which might lead to unexpected behavior if not handled properly.
Maps: Do not have this issue as they do not inherit from Object.prototype.
Here is a simple example to illustrate some of these differences:

Copy
// Using a normal object
let obj = {};
obj['key'] = 'value';
console.log(obj['key']); // Output: value

// Using a Map
let map = new Map();
map.set('key', 'value');
console.log(map.get('key')); // Output: value

// Using a non-string key in Map
let objKey = { id: 1 };
map.set(objKey, 'objectValue');
console.log(map.get(objKey)); // Output: objectValue

// Map maintains insertion order
map.set(1, 'numberKey');
map.set('anotherKey', 'anotherValue');
for (let [key, value] of map.entries()) {
  console.log(key, value); // Output: key value, { id: 1 } objectValue, 1 numberKey, anotherKey anotherValue
}
In summary, while normal objects are suitable for many use cases, Maps provide more flexibility and performance advantages when working with key-value pairs, especially when keys are not strings or when you need to maintain the order of insertion.


  `


  const map1 = new Map();
  map1.set("a1", 1);
  map1.set(10, {test:"text"});

  console.log( map1.get(10) ); // {test:"text"}
  console.log( map1.size ); // 2


  const apple = {name: "Apple"};
  map1.set(apple, {name: "apple"});
  console.log( map1.get(apple) ); // {name: 'apple'}


  for (const obj of map1 ) {
    console.log({ obj });
  }

  map1.delete(10);
  console.log( map1.get(10) ); // undefined
  console.log( map1.has(10) ); // false
  console.log( map1.has("a1") ); // true

  map1.set(NaN, 99);

  console.log(map1);
  const iterator1 = map1.entries();

  for (const entry of map1.entries()) {
    console.log(entry);
  }

  console.log( iterator1.next() ); // {value: Array(2), done: false}
  let result = iterator1.next(); // if done is not true means there are other

  while (!result.done) {
    console.log(result.value);
    result = iterator1.next();
  }

  for (const [key, value] of map1) {
    console.log("map1: " + key + " " + value);
  }


  const map2 = new Map([ ["key1", 8], ["key2", 99] ]);
  map2.forEach(function(key, value){
    console.log(key, value);
  });

  console.log("merged:");
  const map3 = new Map([...map1, ...map2]);
  map3.forEach(function(key, value){
    console.log(key, value);
  });



</script>

</body>
</html>
