<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
      body {
          background: black;
          color: white;
      }

      * {
          margin: 20px 2px;
      }

  </style>
</head>
<body>

<script>

  const operands = `
  Operatory umożliwiają operacje na operandach, niektóre
  operatory operują na jednym a inne na dwóch, czasem nawet
  na trzech operandach.
  let result = (2 + 5) * 10;
  2, 5, 10 to operandy
  + oraz * to operatory matematyczne
  2 + 5 to wyrażenie arytmetyczne dające wartość (arithmetic expression)
`
  //1.
  const arithmeticOperators = ` Arithmetic operators: +, -, *, /, %`
  console.log(arithmeticOperators);

  let num = 6;
  num++;
  num--;

  //2.
  // const assignmentOperators = `Assignment operators: =, +=, -=, *=, /=, %=`
  // console.log(assignmentOperators);
  //
  // const name = "Kasia"; // = to operator przypisania // assignment operator
  //
  // let aa = 10;
  //
  // aa += 2;
  // console.log(aa); // 12 to samo  a = a + 2
  //
  // aa -= 6; //aa = aa - 2
  //
  // aa *= 3; //aa = aa * 2
  //
  // aa /= 9; //aa = aa / 2
  //
  // aa **= 3; // a = a ** 3


  //3.
  const moduloOperator = `operator modulo pozwala na uzyskanie reszty z dzielenia`
  // console.log(moduloOperator);
  //
  // console.log( 10 % 4 ); // 2
  // console.log( 43 % 3 ); // 1
  // console.log( 43 % 43 ); // 0
  //
  // console.log( 10 % 2 ); // 0 bo parzysta
  // console.log( 11 % 2 ); // 1 bo nieparzysta
  // console.log( 13 % 2 ); // 1 bo nieparzysta



  const arr = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8];

  for (let i = 0; i < arr.length; i++) {
    const n = arr[i];

    if ( (n % 2) == 0 ) {
      console.log(n, "to liczba parzysta");
    } else {
      console.log(n, "to liczba nieparzysta");
    }
  }

  /*
   Modulo zadanie:
   Oblicz sumę parzystych elementów
   tablicy liczb od 1 do 14, krok co 1
   */


  const arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14];
  let sum = 0;

  for (let i = 0; i < arr.length; i++) {
    const n = arr[i];

    if ( (n % 2) == 0 ) {
      sum += n;
    }
  }

  console.log("Sum:", sum); // 56

  //5.
  const incrementation_decrementation = `
   Inkrementacja i dekrementacja są to jednoargumentowe
   operatory matematyczne zwiększające i zmniejszające
   wartość zmiennej o 1
   `
  // console.log(incrementation_decrementation);

  let n = 10;
  n++; // 11

  // console.log(n++); // 11, najpierw pobrana wartość do log i po tym zwiększona o 1
  // console.log(n); // 12

  n = 11;
  // console.log(++n); // 12, najpierw zwiększone n o 1,
                    // następnie przekazane do log

  n = 20;
  // console.log(n--); // 20
  // console.log(n); // 19

  n = 20;
  // console.log(--n); // 19
  // console.log(n); // 19


  //6.
  const ternaryOperator = `
   ternary - operator trójargumentowy zwany również
   trójelementowym, to w praktyce skrócona instrukcja if else
   `
  // console.log(ternaryOperator);

  let speed = 250;

  if (speed > 200) {
    // console.log("szybko");
  } else {
    // console.log("wolno");
  }


  let result = speed > 200 ? "szybko" : "wolno";
  console.log(result); // wolno


  //7.
  const equalityOperator = `
   Operatory porównania porównują lewy operand z prawym,
   zwracają true jeśli warunek jest spełniony, natomiast
   false jeśli nie.

  `


  // console.log(equalityOperator);

  // console.log( 6 > 1 ); // true
  // console.log( 6 < 1 ); // false
  //
  // console.log( 10 >= 6 ); // true
  // console.log( 10 >= 10 ); // true
  // console.log( 10 >= 22 ); // false
  //
  // console.log( 5 <= 7 ); // true
  // console.log( 5 <= 5 ); // true
  // console.log( 5 <= 1 ); // false

  let age = 18;

  if (age >= 18) {
    // console.log("Może głosować");
  } else {
    // console.log("Nie może głosować");
  }

  // console.log( 1 == 1 ); // true
  // console.log( 1 == 3 ); // false
  // console.log( 1 != 3 ); // true
  //


  const equalityOperatorsWithObjects = `
   Operatory równości w przypadku sprawdzania obiektów tylko
   stwierdzają czy dwa obiekty mają ten sam adres w pamięci!
   Wynika to z tego że dany obiekt, a raczej uchwyt do
   niego może być przechowywany w wielu zmiennych czy stałych,
   bo to typ złożony.
   `

  const whatHappened = `
  let a = 10;
  let b = a; // 10 jest skopiowane do zmiennej b
  b++;

  console.log("a:", a); // 10
  console.log("b:", b); // 11

  let obj = { a: 10 };
  let data = obj; // data i obj wskazują na to samo miejsce w pamięci
                  // do data została przekazana referencja do obiektu w obj

  obj.a++;
  console.log("obj.a:", obj.a); // 11
  console.log("data.a:", data.a); // 11

  // w tym wypadku obie zmienne wskazuja ten sam obiekt

  if (obj == data) {
    // czy obj wskazuje na to samo miejsce w pamięci co data
    console.log("Wskazują na to smao miejsce w pamięci")
  } else {
    console.log("Nie wskazują na to samo miejsce w pamięci");
  }

  let info = { a: 12, b: 15 };
  if (obj == info) {
    // czy obj wskazuje na to samo miejsce w pamięci co info
    console.log("Wskazują na to samo miejsce w pamięci")
  } else {
    console.log("Nie wskazują na to samo miejsce w pamięci");
  }

  // `


  //8.
  const strictEqualityOperators = `
        Ścisłe operatory porównania tzn. === sprawdzają zarówno czy
        obie wartości są równe, ale dodatkowo czy ich typ jest taki
        sam. Jeżeli wartości są takie same np ze względu
        na automatyczną konwersję, ale typ się nie zgadza
        to === zwróci false

        console.log( 4 == 4 ); // true
        console.log( 4 == "4" ); // true

        console.log( 4 === "4" ); // false, bo typ wartości się nie zgadza
        console.log( 4 === 4 ); // true, zgadza się typ - liczby i wartość
        console.log( 4 === 5 ); // false

        // ścisłe sprawdzenie czy wartości nie są sobie równe
        console.log( 5 !== 5 ); // false, bo zgadza są takie same: typ i wartość
        console.log( 5 !== "5" ); // true, nie są równe bo typ się nie zgadza

  `

  //9.
  const comaOperator = `
       /*
            operator przecinka pozwala na zapisanie wielu wyrażeń
            tam gdzie zwykle wpisujemy jedno wyrażenie
        */

        let a = 7, b = 10;
        console.log(b); // 10

        for (let i = 0, j = 5; i < 8; i++, j--) {
            console.log(i, j);
        }

  `

  //10.
  const logicalAndOperator = `

        /*
            Operator logiczny and czyli && umożliwia sprawdzenie kilku
            warunków za jednym razem. Jeśli wszystkie warunki zwrócą
            true to and również na końcu zwróci true.
        */


        console.log( true && true ); // true
        console.log( true && false ); // false
        console.log( false && true ); // false
        console.log( false && false ); // false

        console.log( 5 >= 5 && 1 < 4 ); // true
        console.log( 7 == 8 && 1 < 4 ); // false
        console.log( 7 == 7 && 10 > 12 ); // false
        console.log( 7 != 7 && 10 > 12 ); // false

        console.log( 1 == 1 && 2 == 2 && 3 != 9 ); // true
        console.log( 1 == 1 && 2 == 2 && 3 == 10 ); // false
  `

  const test = "" || false; // false
  const test2 = "" ?? false; // ""

//11.
  const logicalOrOperator = `
         /*
            Operator logiczny or czyli || zwróci prawdę jeśli chociaż
            jeden warunek jest spełniony.
            Zwróci false jeśli wszystkie warunki dają false.
        */

        console.log( true || true ); // true
        console.log( false || true ); // true
        console.log( true || false ); // true
        console.log( false || false ); // false

        console.log( 1 == 1 || 2 > 0 ); // true
        console.log( 1 != 1 || 2 > 0 ); // true
        console.log( 1 == 1 || 2 < 0 ); // true
        console.log( 1 != 1 || 2 < 0 ); // false

        console.log( 3 >= 0 || 1 == 2 || 5 < 10 || 0 != 0 ); // true

  `
//12.
  const logicalNotOperator = `
        /*
            not operator - czyli operator logiczny negacji, który
            odwraca wartość logiczną np.: !true zamieni się na false
        */

        console.log( !true ); // false
        console.log( !false ); // true


        if ( !(6 >= 2) ) console.log("test");

        let emailSent = false;

        if (emailSent === false) {
            console.log("Trzeba wysłać email");
        }

        // czy email nie został wysłany
        if (!emailSent) { // czy w emailSent nie ma wartości true
            console.log("Trzeba wysłać email");
        }

        if (emailSent) { // czy email został wysłany
            console.log("email został wysłany");
        }

        if (!false) console.log("#1"); // true
        if (!true) console.log("#2"); // false

        if ( !(6 >= 4) ) console.log("#3"); // false
        if ( !(12 == 12) ) console.log("#4"); // false

        let flag = false;
        if (flag) console.log("#5"); // false
        if (!flag) console.log("#6"); // true

  `

  //13.
  const unaryOperators = `
        /*
            unary operators - operatory jednoargumentowe
            czyli przyjmują pojedyńczy operand
            - inkrementacja,
            - dekrementacja,
            - delete
        */

        let n = 8;
        n++;
        n--;

        let result = "15" + 20;
        console.log(result); // "1520"

        result = +"15" + 20;
        console.log(result); // 35

        result = -"15" + 20;
        console.log(result); // 5

  `

  const deleteOperator = `
  /*
  usuwa pole z obiektu
  */
  `
  let testDeleteOperator = { a: 12, b: 15, c: 17 };
  delete testDeleteOperator.b;
  console.log(testDeleteOperator); // {a: 12, c: 17}



//14.
  const relationalOperators = `
  /*
   operatory relacyjne porównują
   operandy i zwracają true jeśli spełnione jest porównanie
   - in
   - instanceof
   */

   let obj = { a: 12, b: 14, c: 15 };

  console.log( "b" in obj ); // true
  console.log( "d" in obj ); // false


  let arr = ["f", "g", "h", "i"];

  console.log( 0 in arr ); // true
  console.log( 8 in arr ); // false



  let date = new Date(2030, 12, 15);
  if (date instanceof Date) console.log("Prawidłowa data");


   `

  // 15.
  const typeofOperator = `
    /*
     operator zwracający
     typ wartości w zmiennej lub stałej.
    */

        console.log( typeof 20 ); // "number"
        console.log( typeof "str" ); // "string"
        console.log( typeof "56" ); // "string"
        console.log( typeof true ); // "boolean"
        console.log( typeof {} ); // "object"
        console.log( typeof { a: "str" } ); // "object"
        console.log( typeof [1,2,3,4] ); // "object"
        console.log( typeof undefined ); // "undefined"
        console.log( typeof 123234234n ); // "bigint"
        console.log( typeof Symbol() ); // "symbol"
        console.log( typeof console.log ); // "function"
        console.log( typeof null ); // "object"

        let data = { name: "Kasia" };

        if (typeof data === "number") {
            console.log(data, "jest liczbą");
        } else if (typeof data === "string") {
            console.log(data, "jest łańcuchem znaków");
        } else if (typeof data === "object") {
            console.log(data, "jest obiektem");
        }
  `

  const typeOfNull =
          `type of null returns object - an error in js since the beginning - it will never be fixed due to backward compatibility`

  const nullTest = typeof null;
  console.log(nullTest);

  //16.
  const doubleNegation = `
        /*
            Negacja wymusza konwersję na boolean i odwraca znak,
            ale podwójna negacja w praktyce konwertuje
            "prawdziwe" wartości na true, a "falsy" na false
        */


  WARTOSC ROZNA OD 0 ROWNIEZ WARTOSCI MINUSOWE TO TRUE!!!

        console.log(!-1); // false, wartość różna od zera zamieniana jest na true
        console.log(!0); // true

        console.log(!!1); // true
        console.log(!!-1); // true
        console.log(!!0); // false


`

let a = 0
a += 2;

  if (" ") console.log(`truthy`);
  const testEmptyString = ""; // falsy
  const testEmptyString2 = " "; // truthy
  console.log(!testEmptyString); // true
  console.log(!testEmptyString2); // false
  // string with empty space is not an empty string

const operators = `
  *Operators*
  Assignment operators: =, +=, -=, *=, /=, %=
  Comparison operators: ==, !=, ===, !==, >, >=, <, <=
  Logical operators: &&, ||, !

  1. && (Logical AND): This operator returns true if both operands are true, otherwise it returns false. It is often used to check multiple conditions.
  2. || (Logical OR): This operator returns true if at least one of the operands is true, otherwise it returns false. It
  is often used to check multiple conditions.
  3. ! (Logical NOT): This operator negates the boolean value of its operand. It returns true if the operand is false,
    and false if the operand is true.

   The && operator returns true if both operands are true, otherwise it returns false.
   The || operator returns true if at least one operand is true, otherwise it returns false.
   The ! operator negates the value of its operand. If the operand is true, it returns false, and if the operand is false, it returns true.
   Bitwise operators: &, |, ^, ~, <<, >>, >>>
  Conditional (ternary) operator: ? :
  Nullish coalescing operator: ?? /null undefined
  Optional chaining operator: ?.
  Nullish coalescing assignment operator: ??=
  Logical nullish assignment operator: ||=

`

</script>



</body>
</html>
