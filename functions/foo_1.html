<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>functions</title>
</head>
<body>

    <script>

        const functionsIntro = `
        /*
         Funkcje pozwalają na wielokrotne wywołanie danego kodu.
         Tworzymy je za pomocą słowa kluczowego function oraz
         dowolnej nazwy funkcji. Wywołujemy ją z pomocą
         nawiasów okrągłych ().

         Funkcja może przyjmować dane przy jej wywołaniu,
         w deklaracji podajemy je po przecinku i są to
         wewnętrzne zmienne funkcji zwane parametrami.
         Natomiast przy wywołaniu funkcji przekazywane
         dane do funkcji nazywamy parametrami.

         - PARAMETRY TYLKO PODCZAS DEKLARACJI FUNKCJI
         - ARGUMENTY PODCZAS WYWOŁANIA

         Jeśli funkcja nic nie zwraca, to zwraca domyślnie undefined.
         */
         `

        const functionDeclaration = `
        // deklaracja funkcji //
        // a, b, c, d to parametry // function params

        function test(a, b, c, d) {
            let sum = a + b + c + d;
            return sum;
        }
        `

        const functionCall = `
        // wywołanie funkcji
        // 1,2,3,4 to argumenty
        let result = test(1,2,3,4);

        // console.log(result); // 10

        function multiply(a, b) {
            let sum = a * b;
            return sum;
        }

        // console.log(multiply(3, 10));
        `

        const functionExpression = `

        /*
         function expression - wyrażenie funkcyjne to funkcja
         anonimowa przypisana do zmiennej lub stałej
         */

        let anonymousFoo = function (a, b) {
            return a + b;
        }

        console.log( anonymousFoo(5, 10) ); // 15


        anonymousFoo = function (a, b) {
            return a - b;
        }

        console.log( anonymousFoo(5, 10) ); // -5
        `

        const callback = `
        /*
         callback - to funkcja przekazana jako argument do innej
         funkcji, dzięki czemu może być wewnątrz jej wywołana
         */

        function show(txt) {
            console.log(txt);
        }

        function showArr(arr, callback) {
            for (let i = 0; i < arr.length; i++) {
                const num = arr[i];
                callback(num);
            }
        }

        const tab = [1,2,3,4,5];

        showArr(tab, show);
        `

        function callbackFoo(el) {
            // console.log(el);
        }

        function greaterThanSix(arr, callback) {
            for(let i = 0; i< arr.length; i++ ) {
                let num = arr[i]
                if (num > 6) {
                    callback(num)
                }
            }
        }

        greaterThanSix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], callbackFoo)


        const argumentsObject = `
        /*
         Obiekt arguments w funkcji posiada przekazane argumenty
         przy wywołaniu funkcji. Obiekt ten dostępny jest tylko
         w zwykłych funkcjach, nie ma go w funkcjach strzałkowych.
         Czyli deklarujemy funkcje bez argumentow a nastepnie mamy dostep do wszystkiego co takiej funkcji zostanie przekazane!
         */
         `

        function sumAll() {67654
            let result = 0;
            for (let i = 0; i < arguments.length; i++) {
                result += arguments[i];
            }
            return result;
        }

        // console.log( sumAll(1,2,3) ); // 6
        // console.log( sumAll(1,2,3,4,5,6,7,8,9,10,11,12,13,14) ); // 105

        const objectsInFunctions = `
        /*
         Prymitywy przekazywane są przez kopię, a obiekty przez
         referencję, czyli tak naprawdę wskaźnik do adresu
         pamięci gdzie rezyduje obiekt.
         Obiekty zatem mogą być zmieniane po przekazaniu do funkcji.
         */

`
        const objectsInFunctionsExamples = `

        function foo(num, obj) {
            num = 12;
            obj.data = "test!";
        }

        let a = 7;
        let data = { data: "text" };
        foo(a, data);

        // console.log("a:", a); // 7 - zostało nie zmienione
        // console.log("data:", data); // 'test!' - zmieniło się, bo operowaliśmy na referencji

        let myArrToBeModified = [1, 2, 3]

        function multiplyBy3(arr) {
            for (let i = 0; i < arr.length; i++) {
                 arr[i] *= 3
            }
        }
        multiplyBy3(myArrToBeModified)

        // zmieniliśmy oryginalny array
        console.log(myArrToBeModified);
`

        const nestedFoo = `
               /* Funkcje zagnieżdżone */

        function test(arr) {
            function show(data) {
                console.log(data);
            }

            for (let i = 0; i < arr.length; i++) {
                show(arr[i] * 2);
            }
        }

        test([1,2,3,4,5]);

        `

        const defaultArguments = `
             /*
            Domyślne argumenty funkcji dostępne
            są od EcmaScript2015 - ES6
        */

        function createEmployee(name = "unknown",
                                surname = "unknown",
                                email = "unknown@example.com") {
            return {
                name: name,
                surname: surname,
                email: email
            };
        }

        console.log( createEmployee() );
        console.log( createEmployee("Ola") );
        console.log( createEmployee("Ola", "Kowalska") );
        console.log( createEmployee("Ola", "Kowalska", "ola@example.com") );
        `


    </script>



















</body>
</html>
